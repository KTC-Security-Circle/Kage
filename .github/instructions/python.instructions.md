---
applyTo: "**/*.py"
description: "Python coding conventions and development guidelines"
---

# Python Coding Conventions and Development Guidelines

This document outlines the coding standards, conventions, and best practices to be followed when writing Python code for this project. Adherence to these guidelines ensures code that is readable, maintainable, and consistent.

## 1. Design Principles

Always adhere to the following core software design principles:

- YAGNI (You Aren't Gonna Need It): Do not implement features that are not currently required. Avoid speculative implementations for future needs.
- DRY (Don't Repeat Yourself): Avoid code duplication. Abstract common logic into reusable functions, classes, or modules.
- KISS (Keep It Simple, Stupid): Prefer simple, straightforward solutions over complex ones. A simple, understandable implementation is better than a clever but obscure one.

## 2. Code Style, Formatting, and Linting

- PEP 8: All Python code must follow the PEP 8 style guide.
- Formatter & Linter: We use Ruff for formatting and linting.
  - Before committing, run `uv run poe fix` (which executes ruff format and ruff check --fix) to format your code and automatically fix any issues. Manually correct any remaining warnings or errors.
- Indentation: Use 4 spaces for each level of indentation.
- Line Length: Limit all lines to a maximum of 79 characters where possible, though slight extensions are permissible if they improve readability.
- Blank Lines: Use blank lines to separate functions, classes, and logical blocks of code to improve readability.

## 3. Naming Conventions

- Variables & Functions: Use snake_case (e.g., user_name, calculate_total).
- Classes: Use PascalCase (e.g., UserAccount, DatabaseConnection).
- Constants: Use UPPER_SNAKE_CASE (e.g., MAX_CONNECTIONS, API_ENDPOINT).

## 4. Type Hinting

- Mandatory Typing: All function and method arguments and return values must include type hints.
- Use Specific Types: Use types from the typing module (e.g., List[str], Dict[str, int]).
- Avoid Any: The use of typing.Any and typing.Optional should be minimized.
- Custom Types: For application-specific data structures, actively define and use custom types like TypedDict or dataclasses to ensure clarity and type safety.

## 5. Comments and Docstrings

- Docstrings: All public modules, functions, classes, and methods must have docstrings following the Google Python Style Guide.
- Clarity: Write clear and concise comments to explain complex logic, algorithms, or design decisions.
- AI-Generated Comments: Prefix any comments generated by AI with [AI GENERATED].

Example of Proper Documentation
from typing import Dict

```python
def process_user_data(user_id: int, data: Dict[str, str]) -> bool:
    """Processes user data and updates the database.

    This function retrieves a user by their ID, validates the incoming data,
    and updates the corresponding record in the database.

    Args:
        user_id (int): The unique identifier for the user.
        data (Dict[str, str]): A dictionary containing the user data to update.

    Returns:
        bool: True if the update was successful, False otherwise.

    Raises:
        UserNotFoundError: If no user with the given user_id exists.
    """
    if not _is_valid(user_id):
        # [AI GENERATED] The user ID must be a positive integer.
        return False
    # ... implementation details ...
    return True
```

## 6. Project and Module Structure

- src Layout: All source code must be located within the src/ directory.
- Separation of Concerns: Divide the application into modules based on functionality to maintain a clear separation of concerns (e.g., views, logic, models, agents).
- No Circular Imports: Circular dependencies between modules are strictly forbidden and must be refactored if they occur.

## 7. Error Handling

- Custom Exceptions: Use custom exception classes to convey specific error conditions.
- User-Facing Messages: The views layer should catch exceptions and present clear, user-friendly error messages.
- Specific except Blocks: Always catch specific exceptions. Avoid generic except Exception: blocks.
- Logging: Use loguru.logger.exception() within an except block to log the full stack trace and provide context.
- User Notifications: Use UI components like Flet's AlertDialog or SnackBar to inform the user of errors.

## 8. Configuration and Secrets Management

- Environment Variables: Do not hardcode secrets (like API keys) in the source code. Manage them using a .env file.
- .gitignore: Ensure that the .env file is included in your .gitignore to prevent it from being committed to the repository.
- Loading: Use the setup_environment function in env.py to load these environment variables.

## 9. Logging

- Library: Use Loguru for all application logging.
- Log Levels: Use appropriate log levels (DEBUG, INFO, WARNING, ERROR, CRITICAL) to provide useful information for debugging and monitoring.
- Configuration: All logger settings are defined in logging_conf.py. Use the setup_logger function from this module to ensure consistent logging throughout the application.

## 10. Edge Cases and Testing

- Test Coverage: Always include test cases for the critical paths of your application.
- Edge Cases: Account for common edge cases such as empty inputs, invalid data types, and large datasets. Document the expected behavior for these cases with comments or in tests.
- Unit Tests: Write unit tests for functions and document them with docstrings that explain the test cases.
