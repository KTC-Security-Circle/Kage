新規 View モジュール作成の依頼
src/views/memos（MVP+State+Query/Ordering 構成）のやり方でsrc/views/projects
を実際にこの方式に置き換えてください


目的:
- 設計（MVP + State コンテナ + Query/Ordering 分離）で、新規画面モジュールを追加してください。
- テスタブルで保守性の高い構成を統一します。

対象:
- モジュール名: {feature}（例: tasks, projects など）
- 配置先: src/views/{feature}

作業内容:
1) 下記のディレクトリ/ファイルを作成
- view.py: Flet の描画とイベント配線の最小限のみ
- presenter.py: 表示用データ整形（Domain→Presentation Model）
- state.py: UI 状態（選択・フィルタ・並び順など）の単一コンテナ
- controller.py: ユーザー操作→State 更新→再描画の調停
- query.py: 取得系ロジックの抽象化（CQRS の Query 側）
- ordering.py: 並び替え戦略の切替（Strategy）
- components/: 再利用 UI 部品（必要に応じて shared/constants.py を新設）

2) コーディング規約
- すべて型ヒント必須、公開関数は Google スタイルの docstring
- UI と状態更新を分離（page.update() は Controller 側のトリガで統一）
- ログは loguru を使用
- セキュリティ: eval/exec/pickle（ユーザー入力由来）は使用禁止

3) テスト
- tests/views/{feature}/ 以下に pytest を追加
- 少なくとも State、Presenter、Ordering はユニットテストを作成
- 外部依存はモック化

受け入れ条件（DoD）:
- uv run poe check / uv run poe test をパス
- 型チェック（pyright）・lint/format（ruff）をパス
- 並び替えとフィルタ変更が State→Presenter→View に反映されるデモがある
- コンポーネントは ft.UserControl ベースで再利用可能

参考:
- 同等の責務分割と命名でお願いします

スケルトン例（{feature} を実名に置換して作成）:

````python
from __future__ import annotations
from dataclasses import dataclass, replace
from typing import Optional, Literal

SortKey = Literal["created_at", "updated_at", "priority"]
StatusFilter = Optional[Literal["open", "in_progress", "done"]]

@dataclass(frozen=True)
class {Feature}State:
    """単一のUI状態コンテナ。イベント駆動でのみ更新する。"""
    keyword: str = ""
    status: StatusFilter = None
    sort_key: SortKey = "updated_at"
    sort_desc: bool = True
    selected_id: Optional[str] = None

    def update(self, **changes: object) -> "{Feature}State":
        """不変更新。常に新しいインスタンスを返す。"""
        return replace(self, **changes)
````

````python
from __future__ import annotations
from dataclasses import dataclass
from typing import Protocol, Iterable, Callable, Any

class OrderStrategy(Protocol):
    def key(self, item: dict) -> Any: ...

@dataclass
class FieldOrder:
    """単純なフィールドベースの並び替え。"""
    field: str

    def key(self, item: dict) -> Any:
        # NOTE: フィールド欠落時の安定動作を担保
        return item.get(self.field, None)

ORDERING_MAP: dict[str, OrderStrategy] = {
    "created_at": FieldOrder("created_at"),
    "updated_at": FieldOrder("updated_at"),
    "priority": FieldOrder("priority"),
}

def apply_order(items: Iterable[dict], strategy: OrderStrategy, desc: bool) -> list[dict]:
    return sorted(items, key=strategy.key, reverse=desc)
````

````python
from __future__ import annotations
from typing import Protocol, Iterable

class {Feature}Query(Protocol):
    def list_items(self, keyword: str, status: str | None) -> Iterable[dict]: ...

class InMemory{Feature}Query:
    """軽量なデフォルト実装。テスト・プロトタイピング用。"""
    def __init__(self, data: list[dict]) -> None:
        self._data = data

    def list_items(self, keyword: str, status: str | None) -> list[dict]:
        items = self._data
        if keyword:
            k = keyword.lower()
            items = [x for x in items if k in str(x.get("title", "")).lower()]
        if status:
            items = [x for x in items if x.get("status") == status]
        return items
````

````python
from __future__ import annotations
from dataclasses import dataclass
from typing import Iterable

@dataclass(frozen=True)
class {Feature}CardVM:
    id: str
    title: str
    subtitle: str

def to_card_vm(items: Iterable[dict]) -> list[{Feature}CardVM]:
    """Domain(dict) → ViewModel への最小変換。"""
    return [
        {Feature}CardVM(
            id=str(x.get("id")),
            title=str(x.get("title", "")),
            subtitle=str(x.get("updated_at", "")),
        )
        for x in items
    ]
````

````python
from __future__ import annotations
from typing import Callable
from .state import {Feature}State
from .query import {Feature}Query
from .ordering import ORDERING_MAP, apply_order
from .presenter import to_card_vm

class {Feature}Controller:
    """イベント→状態→データ取得→並び替え→VM 生成→再描画の調停役。"""

    def __init__(self, query: {Feature}Query, on_change: Callable[[list], None]) -> None:
        self._query = query
        self._state = {Feature}State()
        self._on_change = on_change

    @property
    def state(self) -> {Feature}State:
        return self._state

    def set_keyword(self, keyword: str) -> None:
        self._update_and_render(self._state.update(keyword=keyword))

    def set_status(self, status: str | None) -> None:
        self._update_and_render(self._state.update(status=status))

    def set_sort(self, key: str, desc: bool) -> None:
        self._update_and_render(self._state.update(sort_key=key, sort_desc=desc))

    def _update_and_render(self, new_state: {Feature}State) -> None:
        self._state = new_state
        items = self._query.list_items(new_state.keyword, new_state.status)
        strategy = ORDERING_MAP[new_state.sort_key]
        ordered = apply_order(items, strategy, new_state.sort_desc)
        vm = to_card_vm(ordered)
        self._on_change(vm)
````

````python
from __future__ import annotations
import flet as ft
from typing import Iterable
from .controller import {Feature}Controller
from .query import InMemory{Feature}Query
from .presenter import {Feature}CardVM

class {Feature}View(ft.UserControl):
    """View は描画に集中し、ロジックは Controller に委譲する。"""

    def __init__(self, data_seed: list[dict] | None = None) -> None:
        super().__init__()
        self._list = ft.ListView(expand=True, spacing=8)
        query = InMemory{Feature}Query(data_seed or [])
        self._controller = {Feature}Controller(query, on_change=self._render_items)

    def build(self) -> ft.Control:
        return ft.Column(
            controls=[
                ft.TextField(label="検索", on_change=lambda e: self._controller.set_keyword(e.control.value)),
                ft.Row([
                    ft.Dropdown(
                        label="状態",
                        options=[ft.dropdown.Option("open"), ft.dropdown.Option("in_progress"), ft.dropdown.Option("done")],
                        on_change=lambda e: self._controller.set_status(e.control.value or None),
                    ),
                    ft.Dropdown(
                        label="並び替え",
                        options=[ft.dropdown.Option("updated_at"), ft.dropdown.Option("created_at"), ft.dropdown.Option("priority")],
                        value="updated_at",
                        on_change=lambda e: self._controller.set_sort(e.control.value, self._controller.state.sort_desc),
                    ),
                    ft.Switch(
                        label="降順",
                        value=True,
                        on_change=lambda e: self._controller.set_sort(self._controller.state.sort_key, e.control.value),
                    ),
                ]),
                self._list,
            ],
            expand=True,
        )

    def _render_items(self, items: Iterable[{Feature}CardVM]) -> None:
        self._list.controls = [ft.ListTile(title=ft.Text(i.title), subtitle=ft.Text(i.subtitle)) for i in items]
        self.update()
````

作業手順の目安:
- 雛形の配置 → Presenter/Ordering/State をユニットテスト → Controller 結線 → View 最小描画 → 既存レイアウトへ統合


不明点があれば、src/views/memosを参考にしてください。
